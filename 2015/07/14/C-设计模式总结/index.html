<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>C#设计模式总结 | 小勇blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="小勇">
  
  
    <meta name="description" content="&amp;emsp;&amp;emsp;学习C#编程也有一段时间了，对于面向对象语言编程，我认为不能不知道设计模式。下面是网上的总结佳作，拿来学习学习。原文出处： zhili 的博客（@天平Learning） 
也可参考自己CSDN博客整理：最全设计模式导学目录（完整版），前面几篇学的是java语言的，语法上稍微与C#有点不同，于是再找到此篇文章。">
  
  <meta name="description" content="&amp;emsp;&amp;emsp;学习C#编程也有一段时间了，对于面向对象语言编程，我认为不能不知道设计模式。下面是网上的总结佳作，拿来学习学习。原文出处： zhili 的博客（@天平Learning） 
也可参考自己CSDN博客整理：最全设计模式导学目录（完整版），前面几篇学的是java语言的，语法上稍微与C#有点不同，于是再找到此篇文章。">
<meta property="og:type" content="article">
<meta property="og:title" content="C#设计模式总结">
<meta property="og:url" content="http://fml710.xyz/2015/07/14/C-设计模式总结/index.html">
<meta property="og:site_name" content="小勇blog">
<meta property="og:description" content="&amp;emsp;&amp;emsp;学习C#编程也有一段时间了，对于面向对象语言编程，我认为不能不知道设计模式。下面是网上的总结佳作，拿来学习学习。原文出处： zhili 的博客（@天平Learning） 
也可参考自己CSDN博客整理：最全设计模式导学目录（完整版），前面几篇学的是java语言的，语法上稍微与C#有点不同，于是再找到此篇文章。">
<meta property="og:image" content="http://i.imgur.com/jKDoEtZ.gif">
<meta property="og:image" content="http://i.imgur.com/s2jURfa.gif">
<meta property="og:image" content="http://i.imgur.com/kWmJ9O9.gif">
<meta property="og:image" content="http://i.imgur.com/zyrRFDa.jpg">
<meta property="og:image" content="http://i.imgur.com/iRGJT0j.jpg">
<meta property="og:updated_time" content="2015-07-14T06:45:29.734Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C#设计模式总结">
<meta name="twitter:description" content="&amp;emsp;&amp;emsp;学习C#编程也有一段时间了，对于面向对象语言编程，我认为不能不知道设计模式。下面是网上的总结佳作，拿来学习学习。原文出处： zhili 的博客（@天平Learning） 
也可参考自己CSDN博客整理：最全设计模式导学目录（完整版），前面几篇学的是java语言的，语法上稍微与C#有点不同，于是再找到此篇文章。">
  
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">小勇blog</a></h1>
    <p><a href="/">Walk steps step by step</a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/reading">Reading</a></li>
      
        <li><a href="/about">About</a></li>
      
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content"><article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2015/07/14/C-设计模式总结/">
  <time datetime="2015-07-14T03:16:20.000Z">
    7月 14 2015
  </time>
</a>
    
    
  
    <h1 class="title">C#设计模式总结</h1>
  

  </header>
  
  <div class="entry">
    
      <p>&emsp;&emsp;学习C#编程也有一段时间了，对于面向对象语言编程，我认为不能不知道设计模式。下面是网上的总结佳作，拿来学习学习。原文出处： <a href="http://www.cnblogs.com/zhili/p/DesignPatternSummery.html" target="_blank" rel="external">zhili 的博客（@天平Learning）</a> </p>
<p>也可参考自己CSDN博客整理：<a href="http://blog.csdn.net/bigpudding24/article/details/45307373" target="_blank" rel="external">最全设计模式导学目录（完整版）</a>，前面几篇学的是java语言的，语法上稍微与C#有点不同，于是再找到此篇文章。<a id="more"></a></p>
<h1 id="一、引言">一、引言</h1><p>&emsp;&emsp;经过这段时间对设计模式的学习，自己的感触还是很多的，因为我现在在写代码的时候，经常会想想这里能不能用什么设计模式来进行重构。所以，学完设计模式之后，感觉它会慢慢地影响到你写代码的思维方式。这里对设计模式做一个总结，一来可以对所有设计模式进行一个梳理，二来可以做一个索引来帮助大家收藏。所以，我鼓励大家可以通过做笔记的方式来把自己学到的东西进行梳理，这样相信可以理解更深，更好，我也会一直写下来，之后打算写WCF一系列文章。</p>
<p>&emsp;&emsp;其实WCF内容很早也看过了，并且博客园也有很多前辈写的很好，但是，我觉得我还是需要自己总结，因为只有这样，知识才是自己的，别人写的多好，你看了之后，其实还是别人了，所以鼓励大家几点（对于这几点，也是对自己的一个提醒）：</p>
<p>&emsp;&emsp;要动手实战别人博客中的例子；<br>实现之后进行总结，可以写博客也可以自己记录云笔记等；<br>想想能不能进行扩展，进行举一反三。</p>
<p>系列导航：</p>
<p><a href="http://blog.jobbole.com/78059/" target="_blank" rel="external">C#设计模式(1)——单例模式</a></p>
<p><a href="http://blog.jobbole.com/78062/" target="_blank" rel="external">C#设计模式(2)——简单工厂模式</a></p>
<p><a href="http://blog.jobbole.com/78064/" target="_blank" rel="external">C#设计模式(3)——工厂方法模式</a></p>
<p><a href="http://blog.jobbole.com/78067/" target="_blank" rel="external">C#设计模式(4)——抽象工厂模式</a></p>
<p><a href="http://blog.jobbole.com/78069/" target="_blank" rel="external">C#设计模式(5)——建造者模式（Builder Pattern）</a></p>
<p><a href="http://blog.jobbole.com/78071/" target="_blank" rel="external">C#设计模式(6)——原型模式（Prototype Pattern）</a></p>
<p><a href="http://blog.jobbole.com/78073/" target="_blank" rel="external">C#设计模式(7)——适配器模式（Adapter Pattern）</a></p>
<p><a href="http://blog.jobbole.com/78075/" target="_blank" rel="external">C#设计模式(8)——桥接模式（Bridge Pattern）</a></p>
<p><a href="http://blog.jobbole.com/78077/" target="_blank" rel="external">C#设计模式(9)——装饰者模式（Decorator Pattern）</a></p>
<p><a href="http://blog.jobbole.com/78079/" target="_blank" rel="external">C#设计模式(10)——组合模式（Composite Pattern）</a></p>
<p><a href="http://blog.jobbole.com/78081/" target="_blank" rel="external">C#设计模式(11)——外观模式（Facade Pattern）</a></p>
<p><a href="http://blog.jobbole.com/78083/" target="_blank" rel="external">C#设计模式(12)——享元模式（Flyweight Pattern）</a></p>
<p><a href="http://blog.jobbole.com/78086/" target="_blank" rel="external">C#设计模式(13)——代理模式（Proxy Pattern）</a></p>
<p><a href="http://blog.jobbole.com/78088/" target="_blank" rel="external">C#设计模式(14)——模板方法模式（Template Method）</a></p>
<p><a href="http://blog.jobbole.com/78101/" target="_blank" rel="external">C#设计模式(15)——命令模式（Command Pattern）</a></p>
<p><a href="http://blog.jobbole.com/78117/" target="_blank" rel="external">C#设计模式(16)——迭代器模式（Iterator Pattern）</a></p>
<p><a href="http://blog.jobbole.com/78119/" target="_blank" rel="external">C#设计模式(17)——观察者模式（Observer Pattern）</a></p>
<p><a href="http://blog.jobbole.com/78124/" target="_blank" rel="external">C#设计模式(18)——中介者模式（Mediator Pattern）</a></p>
<p><a href="http://blog.jobbole.com/78126/" target="_blank" rel="external">C#设计模式(19)——状态者模式（State Pattern）</a></p>
<p><a href="http://blog.jobbole.com/78128/" target="_blank" rel="external">C#设计模式(20)——策略者模式（Stragety Pattern）</a></p>
<p><a href="http://blog.jobbole.com/78130/" target="_blank" rel="external">C#设计模式(21)——责任链模式</a></p>
<p><a href="http://blog.jobbole.com/78132/" target="_blank" rel="external">C#设计模式(22)——访问者模式（Vistor Pattern）</a></p>
<p><a href="http://blog.jobbole.com/78136/" target="_blank" rel="external">C#设计模式(23)——备忘录模式（Memento Pattern）</a></p>
<h1 id="二、_设计原则">二、 设计原则</h1><p>使用设计模式的根本原因是适应变化，提高代码复用率，使软件更具有可维护性和可扩展性。并且，在进行设计的时候，也需要遵循以下几个原则：<div style="color:red">单一职责原则、开放封闭原则、里氏代替原则、依赖倒置原则、接口隔离原则、合成复用原则和迪米特法则。</div>下面就分别介绍了每种设计原则。</p>
<h2 id="2-1_单一职责原则">2.1 单一职责原则</h2><p>就一个类而言，应该只有一个引起它变化的原因。如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会影响到其他的职责，另外，把多个职责耦合在一起，也会影响复用性。</p>
<h2 id="2-2_开闭原则(Open-Closed_Principle)">2.2 开闭原则(Open-Closed Principle)</h2><p>开闭原则即OCP（Open-Closed Principle缩写）原则，该原则强调的是：一个软件实体（指的类、函数、模块等）应该对扩展开放，对修改关闭。即每次发生变化时，要通过添加新的代码来增强现有类型的行为，而不是修改原有的代码。</p>
<p>符合开闭原则的最好方式是提供一个固有的接口，然后让所有可能发生变化的类实现该接口，让固定的接口与相关对象进行交互。</p>
<h2 id="2-3_里氏代替原则(Liskov_Substitution_Principle)">2.3 里氏代替原则(Liskov Substitution Principle)</h2><p>Liskov Substitution Principle,LSP（里氏代替原则）指的是子类必须替换掉它们的父类型。也就是说，在软件开发过程中，子类替换父类后，程序的行为是一样的。只有当子类替换掉父类后，此时软件的功能不受影响时，父类才能真正地被复用，而子类也可以在父类的基础上添加新的行为。</p>
<h2 id="2-4_依赖倒置原则">2.4 依赖倒置原则</h2><p>依赖倒置（Dependence Inversion Principle, DIP）原则指的是抽象不应该依赖于细节，细节应该依赖于抽象，也就是提出的 “面向接口编程，而不是面向实现编程”。这样可以降低客户与具体实现的耦合。</p>
<h2 id="2-5_接口隔离原则">2.5 接口隔离原则</h2><p>接口隔离原则（Interface Segregation Principle, ISP）指的是使用多个专门的接口比使用单一的总接口要好。也就是说不要让一个单一的接口承担过多的职责，而应把每个职责分离到多个专门的接口中，进行接口分离。过于臃肿的接口是对接口的一种污染。</p>
<h2 id="2-6_合成复用原则">2.6 合成复用原则</h2><p>合成复用原则（Composite Reuse Principle, CRP）就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分。新对象通过向这些对象的委派达到复用已用功能的目的。<div style="color:red">简单地说，就是要尽量使用合成/聚合，尽量不要使用继承。</div></p>
<p>要使用好合成复用原则，首先需要区分”Has—A”和“Is—A”的关系。</p>
<p>“Is—A”是指一个类是另一个类的“一种”，是属于的关系，而“Has—A”则不同，它表示某一个角色具有某一项责任。导致错误的使用继承而不是聚合的常见的原因是错误地把“Has—A”当成“Is—A”.例如：<br><img src="http://i.imgur.com/jKDoEtZ.gif" alt=""></p>
<p>实际上，雇员、经历、学生描述的是一种角色，比如一个人是“经理”必然是“雇员”。在上面的设计中，一个人无法同时拥有多个角色，是“雇员”就不能再是“学生”了，这显然不合理，因为现在很多在职研究生，即使雇员也是学生。</p>
<p>上面的设计的错误源于把“角色”的等级结构与“人”的等级结构混淆起来了，误把“Has—A”当作”Is—A”。具体的解决方法就是抽象出一个角色类：<br><img src="http://i.imgur.com/s2jURfa.gif" alt=""></p>
<h2 id="2-7_迪米特法则">2.7 迪米特法则</h2><p>迪米特法则（Law of Demeter，LoD）又叫最少知识原则（Least Knowledge Principle，LKP），指的是一个对象应当对其他对象有尽可能少的了解。也就是说，一个模块或对象应尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立，这样当一个模块修改时，影响的模块就会越少，扩展起来更加容易。</p>
<p>关于迪米特法则其他的一些表述有：只与你直接的朋友们通信；不要跟“陌生人”说话。</p>
<p>外观模式（Facade Pattern)和中介者模式（Mediator Pattern）就使用了迪米特法则。</p>
<h1 id="三、创建型模式">三、创建型模式</h1><p>创建型模式就是用来创建对象的模式，抽象了实例化的过程。所有的创建型模式都有两个共同点。第一，它们都将系统使用哪些具体类的信息封装起来；第二，它们隐藏了这些类的实例是如何被创建和组织的。创建型模式包括单例模式、工厂方法模式、抽象工厂模式、建造者模式和原型模式。</p>
<ul>
<li><p>单例模式：解决的是实例化对象的个数的问题，比如抽象工厂中的工厂、对象池等，除了Singleton之外，其他创建型模式解决的都是 new 所带来的耦合关系。</p>
</li>
<li><p>工厂方法：创建单个对象，在Abstract Factory有使用到。</p>
</li>
<li><p>抽象工厂：创建一系列相互依赖对象，并能在运行时改变系列。</p>
</li>
<li><p>原型模式：通过拷贝原型来创建新的对象。</p>
</li>
</ul>
<p>　　工厂方法，抽象工厂, 建造者都需要一个额外的工厂类来负责实例化“一个对象”，而Prototype则是通过原型（一个特殊的工厂类）来克隆“易变对象”。</p>
<p>　　下面详细介绍下它们。</p>
<h2 id="3-1_单例模式">3.1  单例模式</h2><p>&emsp;&emsp;单例模式指的是确保某一个类只有一个实例，并提供一个全局访问点。解决的是实体对象个数的问题，而其他的建造者模式都是解决new所带来的耦合关系问题。其实现要点有：</p>
<ol>
<li><p>类只有一个实例。问：如何保证呢？<div style="color:red">答：通过私有构造函数来保证类外部不能对类进行实例化</div></p>
</li>
<li><p>提供一个全局的访问点。问：如何实现呢？<div style="color:red">答：创建一个返回该类对象的静态方法</div></p>
</li>
</ol>
<p>单例模式的结构图如下所示：<br><img src="http://i.imgur.com/kWmJ9O9.gif" alt="单例模式图"></p>
<h2 id="3-2_工厂方法模式">3.2 工厂方法模式</h2><p>工厂方法模式指的是定义一个创建对象的工厂接口，由其子类决定要实例化的类，将实际创建工作推迟到子类中。它强调的是”单个对象“的变化。其实现要点有：</p>
<ol>
<li><p>定义一个工厂接口。问：如何实现呢？<br>答：声明一个工厂抽象类</p>
</li>
<li><p>由其具体子类创建对象。问：如何去实现呢？<br>答：创建派生于工厂抽象类，即由具体工厂去创建具体产品，既然要创建产品，自然需要产品抽象类和具体产品类了。 </p>
</li>
</ol>
<p>其具体的UML结构图如下所示：<br><img src="http://i.imgur.com/zyrRFDa.jpg" alt="工厂方法"></p>
<p>在工厂方法模式中，工厂类与具体产品类具有平行的等级结构，它们之间是一一对应关系。</p>
<h2 id="3-3_抽象工厂模式">3.3 抽象工厂模式</h2><p>抽象工厂模式指的是提供一个创建一系列相关或相互依赖对象的接口，使得客户端可以在不必指定产品的具体类型的情况下，创建多个产品族中的产品对象，强调的是”系列对象“的变化。其实现要点有：</p>
<ol>
<li><p>提供一系列对象的接口。问：如何去实现呢？<br>答：提供多个产品的抽象接口</p>
</li>
<li><p>创建多个产品族中的多个产品对象。问：如何做到呢？<br>答：每个具体工厂创建一个产品族中的多个产品对象，多个具体工厂就可以创建多个产品族中的多个对象了。</p>
</li>
</ol>
<p>具体的UML结构图如下所示：<br><img src="http://i.imgur.com/iRGJT0j.jpg" alt="抽象工厂"></p>
<h1 id="六、总结">六、总结</h1><p>23种设计模式，其实前辈们总结出来解决问题的方式，它们追求的宗旨还是保证系统的低耦合高内聚，指导它们的原则无非就是封装变化，责任单一，面向接口编程等设计原则。之后，我会继续分享自己WCF的学习过程，尽管博客园中有很多WCF系列，之前觉得没必要写，觉得会用就行了，但是不写，总感觉知识不是自己的，感觉没有深入，所以还是想写这样一个系列，希望各位博友后面多多支持。</p>
<p>PS： 很多论坛都看到初学者问，WCF现在还有没有必要深入学之类的问题，因为他们觉得这些技术可能会过时，说不定到时候微软又推出了一个新的SOA的实现方案了，那岂不是白花时间深入学了，所以就觉得没必要深入去学，知道用就可以了。对于这个问题，我之前也有这样同样的感觉，但是现在我觉得，尽管WCF技术可能会被替换，但深入了解一门技术，重点不是知道一些更高深API的调用啊，而是了解它的实现机制和思维方式，即使后面这个技术被替代了，其背后机制也肯定是相似的。所以深入了解了一个技术，你就会感觉新的技术熟悉，对其感觉放松。并且，你深入了解完一门技术之后，你面试时也敢说你很好掌握了这门技术，而不至于说平时使用的很多，一旦深入问时却不知道背后实现原理。这也是我要写WCF系列的原因。希望这点意见对一些初学者有帮助。</p>

    
  </div>
  <footer>
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


<section id="comment">
  <h1 class="title">评论</h1>
  <div class="ds-thread" data-title="C#设计模式总结">
  </div>
</section>
</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2015 <a href="/">小勇</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
  var duoshuoQuery = { short_name: 'fml710' };
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';
    ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>